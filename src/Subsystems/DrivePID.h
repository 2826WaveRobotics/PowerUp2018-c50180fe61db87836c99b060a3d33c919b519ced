// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#ifndef DRIVEPID_H
#define DRIVEPID_H

#include "Commands/PIDSubsystem.h"
#include "WPILib.h"
#include "ctre/phoenix.h"
#include "AHRS.h"

#define PracticeBot

#ifdef PracticeBot

const double c_calibrationValue = 0;

const double c_straightP = 0.01;
const double c_straightI = 0.0;
const double c_straightD = 0;

const double c_turnP = .03; // P = .004, I = 0, D = .0125
const double c_turnI = 0;
const double c_turnD = 0;

const double kToleranceDegrees = 2.0;

#endif

#ifdef CompBot //for tuning

const double c_calibrationValue = 0;

const double c_straightP = 10;
const double c_straightI = 0.0;
const double c_straightD = 0.1;

const double c_turnP = 0.6;
const double c_turnI = 0;
const double c_turnD = 0;

#endif


class DrivePID: public frc::PIDSubsystem {
 public:
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	std::shared_ptr<WPI_TalonSRX> left1;
	std::shared_ptr<WPI_TalonSRX> left2;
	std::shared_ptr<WPI_TalonSRX> left3;
	std::shared_ptr<frc::SpeedControllerGroup> leftDriveGroup;
	std::shared_ptr<WPI_TalonSRX> right1;
	std::shared_ptr<WPI_TalonSRX> right2;
	std::shared_ptr<WPI_TalonSRX> right3;
	std::shared_ptr<frc::SpeedControllerGroup> rightDriveGroup;
	std::shared_ptr<frc::DifferentialDrive> diffDrive;
	std::shared_ptr<frc::Encoder> leftEncoder;
	std::shared_ptr<frc::Encoder> rightEncoder;
	std::shared_ptr<frc::Solenoid> shifter;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	AHRS *gyro;

	//PIDController *turnController;

	DrivePID();
	double ReturnPIDInput() override;
	void UsePIDOutput(double output) override;
	double GetPIDOutput();
	void InitDefaultCommand() override;

	void ArcadeDrive(double forward, double turn);
	void SetSidePower(double left, double right);
	void DriveCurve(double power, double heading);
	void DriveStraight(double power, double heading);
	void DriveDistance(double distance, double power, double heading);
	void DriveAccelerate(double distance, double power);
	void DriveDeaccelerate(double distance, double power);
	void DriveStop(double distance);
	void Rotate(double heading);
	void Shift(bool state);

	double GetRightEncoder();
	double GetLeftEncoder();
	double GetDistance();
	void ZeroEncoders();
	float GetYaw();
	void ZeroYaw();
	void SetPIDs(double kP, double kI, double kD);
	void SetDirection(double heading);
	void DriveTurning(double driverY);
	void UpdateLimelight();
	double AdjustWithVision();
	double OutputX();
	bool IsTargetFound();
	double m_newHeading;

private:

	float m_targetX = 0;
	float m_targetY = 0;
	float m_area = 0;
	float m_skew = 0;

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
};

#endif
