// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"
#include "Commands/AutoCurve.h"
#include "Commands/AutoDrive.h"
#include "Commands/TestCurve.h"
#include "Commands/AutoRotate.h"
#include "Commands/SetElbow.h"
#include "Commands/Z_Command.h"
#include "Commands/SetKirbyKlaw.h"

#include <iostream>
#include "Commands/LeftSwitchExchangeAuto.h"
#include "Commands/RightSwitchExchangeAuto.h"
#include "Commands/RightSwitchTimedAuto.h"
#include "Commands/LeftSwitchTimedAuto.h"
#include "Commands/LeftScaleAuto.h"
#include "Commands/RightScaleAuto.h"

using namespace nt;


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<Drive> Robot::drive;
std::shared_ptr<Kirby> Robot::kirby;
std::shared_ptr<IronCross> Robot::ironCross;
std::shared_ptr<Elevator> Robot::elevator;
std::shared_ptr<Elbow> Robot::elbow;
std::shared_ptr<DrivePID> Robot::drivePID;
std::unique_ptr<OI> Robot::oi;
std::shared_ptr<CompressorSubsystem> Robot::compressorSubsystem;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    //drive.reset(new Drive());
    kirby.reset(new Kirby());
    ironCross.reset(new IronCross());
    elevator.reset(new Elevator());
    elbow.reset(new Elbow());
    drivePID.reset(new DrivePID());
    compressorSubsystem.reset(new CompressorSubsystem());

   	m_gyro = new AHRS(SPI::Port::kMXP, 100);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());

	// Add commands to Autonomous Sendable Chooser
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

	//LED Mode = 1
	//CAM MODE = 1
//	std::shared_ptr<NetworkTable> table = NetworkTable::GetTable("limelight");
//	table->PutNumber("ledMode", 1);
//	table->PutNumber("camMode",1);


	//m_autoMode.AddDefault("DriveStraight", new AutoDrive(150, 0.8, 0));
	//m_autoMode.AddObject("Do Nothing", new Z_Command());

	m_autoMode.AddDefault("Scale Only", new AutoCurve(0.3, 35));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	frc::SmartDashboard::PutData("Auto Modes", &m_autoMode);
}

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){
	compressorSubsystem->StopCompressor();
	drivePID.get()->ZeroYaw();
	//drivePID.get()->ZeroEncoders();
}

void Robot::DisabledPeriodic() {
	frc::Scheduler::GetInstance()->Run();

	//std::cout << " Arm Break Beam: " << RobotMap::kirbyKirbyFull.get()->Get() << std::endl;
	Wait(.001);


}

void Robot::AutonomousInit() {

	std::string gameData;
	gameData = frc::DriverStation::GetInstance().GetGameSpecificMessage();


	if(gameData[0] == 'L') {
		if (gameData[1] == 'L') //LLL
		{
			m_autoMode.AddDefault("Scale Only", new LeftScaleAuto());
			std::cout << " LLL " << std::endl;
		}
		else //LRL
		{
			m_autoMode.AddDefault("Scale Only", new LeftSwitchTimedAuto());
			std::cout << " LRL " << std::endl;
		}
	}
	else {
		if (gameData[1] == 'R') //RRR
		{
			m_autoMode.AddDefault("Scale Only", new RightSwitchTimedAuto());
			std::cout << " RRR " << std::endl;
		}
		else //RLR
		{
			m_autoMode.AddDefault("Scale Only", new RightSwitchTimedAuto());
			std::cout << " RLR " << std::endl;
		}
	}

	autonomousCommand = m_autoMode.GetSelected();
	if (autonomousCommand != nullptr){
		std::cout << "Command" << std::endl;
		autonomousCommand->Start();
	}

	if(!m_gyro){
		m_gyro->ZeroYaw();
	}

	drivePID.get()->ZeroEncoders();
	drivePID.get()->ZeroYaw();
	elbow.get()->ZeroDegrees();

	compressorSubsystem->StartCompressor();

}

void Robot::AutonomousPeriodic() {
	frc::Scheduler::GetInstance()->Run();

}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	if (autonomousCommand != nullptr)
		autonomousCommand->Cancel();

	//elbow.get()->ZeroDegrees();
	elevator.get()->ZeroHeight();
	compressorSubsystem->StartCompressor();

}

void Robot::TeleopPeriodic() {
	frc::Scheduler::GetInstance()->Run();

	//std::cout << " Elevator Height : " << elevator.get()->GetHeight() << " Elevator Sensor: " << elevator.get()->IsSensorTripped() << std::endl;

	//double current = pdp.getCurrent(1); // 16 total channels

//	drivePID.get()->UpdateLimelight();


//	std::shared_ptr<NetworkTable> table = NetworkTable::GetTable("limelight");
//
//	float targetX = table->GetNumber("tx", 0);
//	float targetY = table->GetNumber("ty", 0);
//	float area = table->GetNumber("ta", 0);
//	float skew = table->GetNumber("ts", 0);
//
//	std::cout << "x: " << targetX << "  y: " << targetY << "  a:" << area << "  s:" << skew << std::endl;

//	std::cout << "Arm Encoder: " << elbow.get()->GetPosition()
	//		<< "  Arm Sensor:  " << kirby.get()->GetSwitch() <<std::endl;


	//Drive and Shift To Climb
	if(oi.get()->getDriver()->GetRawButton(8)){
		drivePID.get()->Shift(true);
	}
	else if(oi.get()->getDriver()->GetRawButton(7)){
			drivePID.get()->Shift(false);
		}
	else if(RobotMap::drivePIDShifter->Get()){
		double driverY = oi.get()->getDriver()->GetRawAxis(1);
		//if(driverY < -0.15){
			drivePID.get()->ArcadeDrive(driverY, 0);
		//}
//		else{
//			drivePID.get()->ArcadeDrive(0, 0);
//		}
	}
	else{
		drivePID.get()->ArcadeDrive(oi.get()->getDriver()->GetRawAxis(1), 	-(oi.get()->getDriver()->GetRawAxis(4)));
	}

//Elevator
	double elevatorSpeed = (-1)*oi.get()->getOperatorJS()->GetRawAxis(5);
	double elevatorHeight = elevator.get()->GetHeight();
	elevator.get()->SensorTriggered();

	std::cout << " Joystick: " << elevatorSpeed << " Height: " << elevatorHeight;

	if(((elevatorSpeed > -0.15) && (elevatorSpeed < 0)) || (( elevatorSpeed  < 0.15) && (elevatorSpeed > 0))){
		std::cout << " Deadband " << std::endl;
		elevator.get()->SetElevatorSpeed(0);
	}
	else if(RobotMap::drivePIDShifter->Get()){
		std::cout << "Elevator stop on shifter" << std::endl;
		elevator.get()->SetElevatorSpeed(0);
	}
	else{
		if((elevatorHeight > 0) && (elevatorSpeed > 0.15)){
			std::cout << " Elevator under 0 " <<std::endl;
			elevator.get()->SetElevatorSpeed(elevatorSpeed);
		}
		if((elevatorHeight < 71) && (elevatorSpeed < -0.15)){
			std::cout << " Elevator Over 0 " << std::endl;
			elevator.get()->SetElevatorSpeed(elevatorSpeed);
		}
	}

	//Elbow
	double elbowSpeed = oi.get()->getOperatorJS()->GetRawAxis(1); //Left Y Axis
	bool elbowOverride = oi.get()->getOperatorJS()->GetRawButton(7);
	double elbowPosition = elbow.get()->GetAngle();

	bool operatorY = oi.get()->getOperatorJS()->GetRawButton(4);
	bool operatorB = oi.get()->getOperatorJS()->GetRawButton(2);
	bool operatorA = oi.get()->getOperatorJS()->GetRawButton(1);
	bool operatorX = oi.get()->getOperatorJS()->GetRawButton(3);
	//Operator Y: 0, Operator B: 140, Operator A: 160, Operator X: 20

	//std::cout << " Arm Sensor: " << kirby.get()->GetSwitch() << " Elevator Sensor: " << elevator.get()->IsSensorTripped() <<std::endl;

	if(elbowOverride){
		elbow.get()->ZeroDegrees();
		if(elbowSpeed < -0.15 || elbowSpeed > 0.15){
			elbow.get()->SetElbowSpeed(elbowSpeed);
		}
		else{
			elbow.get()->SetElbowSpeed(0);
		}
	}
	else if(operatorY || operatorB || operatorA || operatorX){
		if(operatorY){
			elbow.get()->SetAngle(0);
		}
		if(operatorB){
			elbow.get()->SetAngle(125);
		}
		if(operatorA){
			elbow.get()->SetAngle(155);
		}
		if(operatorX){
			elbow.get()->SetAngle(15);
		}
	}
	else{
		if(elbowPosition < 0){
			if(elbowSpeed > 0.15){
				elbow.get()->SetElbowSpeed(elbowSpeed);
			}
			else{
				elbow.get()->SetElbowSpeed(0);
			}
		}
		else if (elbowPosition > 160){
			if(elbowSpeed < -0.15){
				elbow.get()->SetElbowSpeed(elbowSpeed);
			}
			else{
				elbow.get()->SetElbowSpeed(0);
			}
		}
		else{
			if((elbowSpeed < -0.15) || (elbowSpeed > 0.15)){
				elbow.get()->SetElbowSpeed(elbowSpeed);
			}
			else{
				elbow.get()->SetElbowSpeed(0);
			}
		}
	}

	//Kirby
	double rightTrigger = oi.get()->getOperatorJS()->GetRawAxis(2); //Intake
	double leftTrigger =  oi.get()->getOperatorJS()->GetRawAxis(3); //Outtake
	double driverLTrigger = oi.get()->getDriver()->GetRawAxis(3);

	if(rightTrigger > 0.15 && leftTrigger < 0.15){
		kirby.get()->SetKirby(-rightTrigger);
	}
	else if (driverLTrigger > 0.15){
		kirby.get()->SetKirby(driverLTrigger);
	}
	else if (rightTrigger < 0.15 && leftTrigger > 0.15){
		kirby.get()->SetKirby(leftTrigger);
	}
	else{
		kirby.get()->KirbyStop();
	}

	bool leftBumper = oi.get()->getOperatorJS()->GetRawButton(5);
	bool xButton = oi.get()->getOperatorJS()->GetRawButton(3);

	if(leftBumper == 1){
		m_intakeLock = false;
	}

	if(m_intakeLock == true){
		kirby.get()->SetKirbyKlaw(m_intakeLock);
	}
	else if(xButton == 1){
		m_intakeLock = true;
	}
	else{
		kirby.get()->SetKirbyKlaw(leftBumper);
	}

}

START_ROBOT_CLASS(Robot);

