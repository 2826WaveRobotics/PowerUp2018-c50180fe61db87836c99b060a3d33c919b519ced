// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"
#include "Commands/AutoCurve.h"
#include "Commands/AutoDrive.h"
#include "Commands/TestCurve.h"
#include "Commands/AutoRotate.h"
#include "Commands/SetElbow.h"
#include "Commands/Z_Command.h"
#include "Commands/RightScaleExchangeAuto.h"
#include "Commands/LeftScaleExchangeAuto.h"
#include "Commands/SetKirbyKlaw.h"

#include <iostream>

using namespace nt;

namespace {
	frc::GenericHID::JoystickHand leftHand = frc::GenericHID::JoystickHand::kLeftHand;
	frc::GenericHID::JoystickHand rightHand = frc::GenericHID::JoystickHand::kRightHand;
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<Drive> Robot::drive;
std::shared_ptr<Kirby> Robot::kirby;
std::shared_ptr<IronCross> Robot::ironCross;
std::shared_ptr<Elevator> Robot::elevator;
std::shared_ptr<Elbow> Robot::elbow;
std::shared_ptr<DrivePID> Robot::drivePID;
std::unique_ptr<OI> Robot::oi;
std::shared_ptr<CompressorSubsystem> Robot::compressorSubsystem;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    //drive.reset(new Drive());
    kirby.reset(new Kirby());
    ironCross.reset(new IronCross());
    elevator.reset(new Elevator());
    elbow.reset(new Elbow());
    drivePID.reset(new DrivePID());
    compressorSubsystem.reset(new CompressorSubsystem());

   	m_gyro = new AHRS(SPI::Port::kMXP, 100);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());

	// Add commands to Autonomous Sendable Chooser
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS


	m_autoMode.AddDefault("Autonomous Command", new AutonomousCommand());
	m_autoMode.AddObject("Do Nothing", new Z_Command());
	m_autoMode.AddObject("DriveStraight", new AutoDrive(150, 0.8, 0));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	frc::SmartDashboard::PutData("Auto Modes", &m_autoMode);
}

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){
	compressorSubsystem->StopCompressor();
	drivePID.get()->ZeroYaw();
	//drivePID.get()->ZeroEncoders();
}

void Robot::DisabledPeriodic() {
	frc::Scheduler::GetInstance()->Run();

	//std::cout << " Arm Break Beam: " << RobotMap::kirbyKirbyFull.get()->Get() << std::endl;
	Wait(.001);


}

void Robot::AutonomousInit() {

	std::string gameData;
	gameData = frc::DriverStation::GetInstance().GetGameSpecificMessage();


	if(gameData[0] == 'L') {
		if (gameData[1] == 'L') //LLL
		{
			//m_autoMode.AddDefault("Scale Only", new LeftScaleExchangeAuto());
			m_autoMode.AddDefault("Scale Only", new SetKirbyKlaw(true));
		}
		else //LRL
		{
			//m_autoMode.AddDefault("Drive Straight", new AutoDrive(150, 0.5, 0));
		}
	}
	else {
		if (gameData[1] == 'R') //RRR
		{
			m_autoMode.AddDefault("Scale Only", new RightScaleExchangeAuto());
			//m_autoMode.AddDefault("Scale Only", new AutoCurve(-0.7, 35));
		}
		else //RLR
		{

		}
	}

	autonomousCommand = m_autoMode.GetSelected() ;
	if (autonomousCommand != nullptr)
		autonomousCommand->Start();

	if(!m_gyro){
		m_gyro->ZeroYaw();
	}

	drivePID.get()->ZeroEncoders();
	drivePID.get()->ZeroYaw();
	elbow.get()->ZeroDegrees();

	compressorSubsystem->StartCompressor();

}

void Robot::AutonomousPeriodic() {
	frc::Scheduler::GetInstance()->Run();

}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	if (autonomousCommand != nullptr)
		autonomousCommand->Cancel();

	elbow.get()->ZeroDegrees();
	elevator.get()->ZeroHeight();
	compressorSubsystem->StartCompressor();

}

void Robot::TeleopPeriodic() {
	frc::Scheduler::GetInstance()->Run();

	//std::cout << " Elevator Height : " << elevator.get()->GetHeight() << " Elevator Sensor: " << elevator.get()->IsSensorTripped() << std::endl;

	//double current = pdp.getCurrent(1); // 16 total channels

	std::shared_ptr<NetworkTable> table = NetworkTable::GetTable("limelight");

	float targetX = table->GetNumber("tx", 0);
	float targetY = table->GetNumber("ty", 0);
	float area = table->GetNumber("ta", 0);
	float skew = table->GetNumber("ts", 0);

	std::cout << "x: " << targetX << "  y: " << targetY << "  a:" << area << "  s:" << skew << std::endl;


	//Drive and Shift To Climb
	if(oi.get()->getDriver()->GetRawButton(8)){
		drivePID.get()->Shift(true);
	}
	else if(oi.get()->getDriver()->GetRawButton(7)){
			drivePID.get()->Shift(false);
		}
	else if(RobotMap::drivePIDShifter->Get()){
		double driverY = oi.get()->getDriver()->GetRawAxis(1);
		//if(driverY < -0.15){
			drivePID.get()->ArcadeDrive(driverY, 0);
		//}
//		else{
//			drivePID.get()->ArcadeDrive(0, 0);
//		}
	}
	else{
		drivePID.get()->ArcadeDrive(oi.get()->getDriver()->GetRawAxis(1), 	-(oi.get()->getDriver()->GetRawAxis(4)));
	}

//Elevator
	double elevatorSpeed = oi.get()->getOperatorJS()->GetRawAxis(5);
	double elevatorHeight = fabs(elevator.get()->GetHeight());
	elevator.get()->SensorTriggered();

	if(RobotMap::drivePIDShifter->Get()){
		std::cout << "Elevator stop on shifter" << std::endl;
		elevator.get()->SetElevatorSpeed(0);
	}
	else if(elevatorHeight>71){
		if(elevatorSpeed < 0){
			elevatorSpeed = 0;

			std::cout << " Speed to zero - UP" << std::endl;
		}
	}
	else if((elevatorHeight < 0) && elevatorSpeed > 0){
		elevatorSpeed = 0;
		std::cout << " Speed to zero - DOWN" << std::endl;
	}
	else if(elevatorSpeed < -0.15 || elevatorSpeed > 0.15){
		elevator.get()->SetElevatorSpeed(elevatorSpeed);
		std::cout <<  " Elevator Speed: " << elevatorSpeed << std::endl;
	}
	else{
		//std::cout << "ZERO" << std::endl;
		elevator.get()->SetElevatorSpeed(0);
	}

	//Elbow
	double elbowSpeed = oi.get()->getOperatorJS()->GetRawAxis(1); //Left Y Axis
	bool elbowOverride = oi.get()->getOperatorJS()->GetRawButton(7);
	double elbowPosition = elbow.get()->GetAngle();

	bool operatorY = oi.get()->getOperatorJS()->GetRawButton(4);
	bool operatorB = oi.get()->getOperatorJS()->GetRawButton(2);
	bool operatorA = oi.get()->getOperatorJS()->GetRawButton(1);
	bool operatorX = oi.get()->getOperatorJS()->GetRawButton(3);
	//Operator Y: 0, Operator B: 140, Operator A: 160, Operator X: 20

	//std::cout << "  Elbow OR: " << elbowOverride << "  ";

	if(elbowOverride){
		elbow.get()->ZeroDegrees();
		if(elbowSpeed < -0.15 || elbowSpeed > 0.15){
			elbow.get()->SetElbowSpeed(elbowSpeed);
		}
		else{
			elbow.get()->SetElbowSpeed(0);
		}
	}
	else if(operatorY || operatorB || operatorA || operatorX){
		if(operatorY){
			elbow.get()->SetAngle(0);
		}
		if(operatorB){
			elbow.get()->SetAngle(125);
		}
		if(operatorA){
			elbow.get()->SetAngle(160);
		}
		if(operatorX){
			elbow.get()->SetAngle(20);
		}
	}
	else{
		if(elbowPosition < 0){
			if(elbowSpeed > 0.15){
				elbow.get()->SetElbowSpeed(elbowSpeed);
			}
		}
		else if (elbowPosition > 160){
			if(elbowSpeed < -0.15){
				elbow.get()->SetElbowSpeed(elbowSpeed);
			}
		}
		else{
			if((elbowSpeed < -0.15) || (elbowSpeed > 0.15)){
				elbow.get()->SetElbowSpeed(elbowSpeed);
			}
			else{
				elbow.get()->SetElbowSpeed(0);
			}
		}
	}

	//Kirby
	double rightTrigger = oi.get()->getOperatorJS()->GetRawAxis(2); //Intake
	double leftTrigger =  oi.get()->getOperatorJS()->GetRawAxis(3); //Outtake
	double driverLTrigger = oi.get()->getDriver()->GetRawAxis(3);

	if(rightTrigger > 0.15 && leftTrigger < 0.15){
		kirby.get()->SetKirby(-rightTrigger);
	}
	else if (driverLTrigger > 0.15){
		kirby.get()->SetKirby(driverLTrigger);
	}
	else if (rightTrigger < 0.15 && leftTrigger > 0.15){
		kirby.get()->SetKirby(leftTrigger);
	}
	else{
		kirby.get()->KirbyStop();
	}

	bool leftBumper = oi.get()->getOperatorJS()->GetRawButton(5);
	bool xButton = oi.get()->getOperatorJS()->GetRawButton(3);

	if(leftBumper == 1){
		m_intakeLock = false;
	}

	if(m_intakeLock == true){
		kirby.get()->SetKirbyKlaw(m_intakeLock);
	}
	else if(xButton == 1){
		m_intakeLock = true;
	}
	else{
		kirby.get()->SetKirbyKlaw(leftBumper);
	}

}

START_ROBOT_CLASS(Robot);

