// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"
#include "Commands/AutoCurve.h"
#include "Commands/ScaleOnlyAuto.h"
#include "Commands/AutoDrive.h"
#include "Commands/TestCurve.h"

#include <iostream>

namespace {
	frc::GenericHID::JoystickHand leftHand = frc::GenericHID::JoystickHand::kLeftHand;
	frc::GenericHID::JoystickHand rightHand = frc::GenericHID::JoystickHand::kRightHand;
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<Drive> Robot::drive;
std::shared_ptr<Kirby> Robot::kirby;
std::shared_ptr<IronCross> Robot::ironCross;
std::shared_ptr<Elevator> Robot::elevator;
std::shared_ptr<Elbow> Robot::elbow;
std::shared_ptr<DrivePID> Robot::drivePID;
std::unique_ptr<OI> Robot::oi;
std::shared_ptr<CompressorSubsystem> Robot::compressorSubsystem;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    drive.reset(new Drive());
    kirby.reset(new Kirby());
    ironCross.reset(new IronCross());
    elevator.reset(new Elevator());
    elbow.reset(new Elbow());
    drivePID.reset(new DrivePID());
    compressorSubsystem.reset(new CompressorSubsystem());

   	m_gyro = new AHRS(SPI::Port::kMXP, 100);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());

	// Add commands to Autonomous Sendable Chooser
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS


	m_autoMode.AddDefault("Autonomous Command", new AutonomousCommand());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	frc::SmartDashboard::PutData("Auto Modes", &m_autoMode);
}

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){
	compressorSubsystem->StopCompressor();
	//drivePID.get()->ZeroYaw();
}

void Robot::DisabledPeriodic() {
	frc::Scheduler::GetInstance()->Run();

	std::cout << " Elevator Sensor: " << RobotMap::elevatorElevatorZero.get()->Get() << " Arm Break Beam: " << RobotMap::kirbyKirbyFull.get()->Get() << std::endl;
	Wait(.001);

//	std::cout << "Elevator: " << elevator.get()->GetHeight() << " Arm: " << elbow.get()->GetAngle() << " Gyro: " << drivePID.get()->GetYaw()
//			 << std::endl;

	//std::cout << " Yaw: " << drivePID.get()->GetYaw() << std::endl;
}

void Robot::AutonomousInit() {

	std::string gameData;
	gameData = frc::DriverStation::GetInstance().GetGameSpecificMessage();

	if(gameData[0] == 'L')
	{
		if (gameData[1] == 'L') //LLL
		{
		m_autoMode.AddDefault("Scale Only", new ScaleOnlyAuto());
			//m_autoMode.AddDefault("TestCurve", new TestCurve(2, -90.0));
			//m_autoMode.AddDefault("Drive Straight", new AutoDrive(-150, -0.5, 0));
		}
		else //LRL
		{
			//m_autoMode.AddDefault("Drive Straight", new AutoDrive(150, 0.5, 0));
		}
	}
	else //gameData[0] = R
	{
		if (gameData[1] == 'R') //RRR
		{

		}
		else //RLR
		{

		}
	}

	autonomousCommand = m_autoMode.GetSelected() ;
	if (autonomousCommand != nullptr)
		autonomousCommand->Start();

	if(!m_gyro){
		m_gyro->ZeroYaw();
	}

	drivePID.get()->ZeroEncoders();
	drivePID.get()->ZeroYaw();

	compressorSubsystem->StartCompressor();
}

void Robot::AutonomousPeriodic() {
	frc::Scheduler::GetInstance()->Run();

	//Zero Elevator and Elbow
	elbow.get()->ZeroDegrees();
	elevator.get()->ZeroHeight();

}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	if (autonomousCommand != nullptr)
		autonomousCommand->Cancel();

	compressorSubsystem->StartCompressor();

}

void Robot::TeleopPeriodic() {
	frc::Scheduler::GetInstance()->Run();


	//Joystick controls
	drivePID.get()->ArcadeDrive(oi.get()->getDriver()->GetRawAxis(1), 	oi.get()->getDriver()->GetRawAxis(4));

	double elevatorSpeed = oi.get()->getOperatorJS()->GetRawAxis(5);
	if(elevatorSpeed < -0.15 || elevatorSpeed > 0.15){
		elevator.get()->SetElevatorSpeed(elevatorSpeed);
	}
	else{
		elevator.get()->SetElevatorSpeed(0);
	}

	double elbowSpeed = oi.get()->getOperatorJS()->GetRawAxis(1);
	if(elbowSpeed < -0.15 || elbowSpeed > 0.15){
			elbow.get()->SetElbowSpeed(elbowSpeed);
		}
		else{
			elbow.get()->SetElbowSpeed(0);
		}


	if(oi.get()->getOperatorJS()->GetRawButton(1)){
		drivePID.get()->Shift(true);

	}
	else if(oi.get()->getOperatorJS()->GetRawButton(2)){
		ironCross.get()->DeployIronCross();
	}
	else if(oi.get()->getOperatorJS()->GetRawButton(3)){
		ironCross.get()->DeployTRexArms(true);
	}
	else if(oi.get()->getOperatorJS()->GetRawButton(4)){
		kirby.get()->SetKirbyKlaw(true);
	}
	else{
		drivePID.get()->Shift(false);
		ironCross.get()->RetractIronCross();
		ironCross.get()->DeployTRexArms(false);
		kirby.get()->SetKirbyKlaw(false);
	}

	//Kirby
	double rightTrigger = oi.get()->getOperatorJS()->GetRawAxis(3);
	double leftTrigger =  oi.get()->getOperatorJS()->GetRawAxis(2);

	if(rightTrigger > 0.15 && leftTrigger < 0.15){
		kirby.get()->SetKirby(-rightTrigger);
	}
	else if (rightTrigger < 0.15 && leftTrigger > 0.15){
		kirby.get()->SetKirby(leftTrigger);
	}
	else{
		kirby.get()->KirbyStop();
	}

	//Zero Elevator and Elbow
	elbow.get()->ZeroDegrees();
	elevator.get()->ZeroHeight();
}

START_ROBOT_CLASS(Robot);

