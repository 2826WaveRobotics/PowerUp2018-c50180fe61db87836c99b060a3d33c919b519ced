// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "AutoDistance.h"
#include <cmath>
#include <iostream>
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutoDistance::AutoDistance(double maxDistance, double maxPower, double minPower, float direction){
	Requires(Robot::drivePID.get());
	std::cout << "AutoDistance: Construct" << std::endl;
	m_distance = maxDistance;
	m_maxPower = maxPower;
	m_direction = direction;
	m_distanceTraveled = 0;
	m_minPower = minPower;
	m_specialCase = false;

	m_distanceTolerance = .5;
	m_velocityTolerance = 2;
	m_midpointMultiplier = .8;
}
AutoDistance::AutoDistance(double maxDistance, double maxPower, double minPower, float direction,
		bool special, double distanceTolerance, double velocityTolerance, double midpointMultiplier){
	Requires(Robot::drivePID.get());
	std::cout << "AutoDistance: Construct" << std::endl;
	m_distance = maxDistance;
	m_maxPower = maxPower;
	m_direction = direction;
	m_distanceTraveled = 0;
	m_modPower = 0;
	m_minPower = minPower;
	m_specialCase = true;

	m_distanceTolerance = distanceTolerance;
	m_velocityTolerance = velocityTolerance;
	m_midpointMultiplier = midpointMultiplier;
}

// Called just before this Command runs the first time
void AutoDistance::Initialize() {
	Robot::drivePID->SetPIDs(c_straightP, c_straightI, c_straightD);
	Robot::drivePID.get()->ZeroEncoders();
	//Robot::drivePID.get()->ZeroYaw();
	Robot::drivePID.get()->SetDirection(m_direction);
//	Robot::drivePID->DriveStraight(1, 0);
}

// Called repeatedly when this Command is scheduled to run
void AutoDistance::Execute() {

	double m_modPower = Robot::drivePID->CheckPower(m_maxPower, m_minPower, m_distance, m_midpointMultiplier); // get the max power allowed to move (basically P)
	//Robot::drivePID->DriveDistance(m_distance, m_modPower, m_direction);

}

// Make this return true when this Command no longer needs to run execute()
bool AutoDistance::IsFinished() {

	double rightDist = Robot::drivePID.get()->GetRightEncoder();
	double leftDist = Robot::drivePID.get()->GetLeftEncoder()*(-1);
	double m_distanceTraveled;
	if(rightDist < 0 ){
		m_distanceTraveled =  (rightDist+leftDist)/2;
	}
	else if (rightDist > 0){
		m_distanceTraveled = ((rightDist+leftDist)/2)*(-1);
	}
	else{
		m_distanceTraveled = 0;
	}


	m_velocity = Robot::drivePID.get()->GetVelocity();

	std::cout << " Distance Traveled: " << m_distanceTraveled << "  Velocity:  " << m_velocity << " Power: "
			<< m_modPower << std::endl;

	if((fabs(fabs(m_distanceTraveled)-fabs(m_distance))<m_distanceTolerance)&&(fabs(m_velocity)<m_velocityTolerance))
		{
			return true;
		}
		else
		{
			return false; // return false, allowing us to destroy this command when a new instance starts
		}

}

// Called once after isFinished returns true
void AutoDistance::End() {
	Robot::drivePID->ArcadeDrive(0, 0);
	Robot::drivePID.get()->ZeroEncoders();
	//Robot::drivePID.get()->ZeroYaw();
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void AutoDistance::Interrupted() {

}
